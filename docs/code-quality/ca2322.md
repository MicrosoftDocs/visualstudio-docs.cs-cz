---
title: 'CA2322: Před deserializaci se ujistěte se, že třída JavaScriptSerializer není inicializována pomocí třídy SimpleTypeResolver'
ms.date: 05/08/2019
ms.topic: reference
author: dotpaul
ms.author: paulming
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
f1_keywords:
- CA2322
- EnsureJavaScriptSerializerIsNotInitializedWithSimpleTypeResolverBeforeDeserializing
ms.openlocfilehash: 6904058a0888897021f20976dfcd73555bdee1ac
ms.sourcegitcommit: d20ce855461c240ac5eee0fcfe373f166b4a04a9
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/29/2020
ms.locfileid: "84182726"
---
# <a name="ca2322-ensure-javascriptserializer-is-not-initialized-with-simpletyperesolver-before-deserializing"></a>CA2322: Před deserializaci se ujistěte se, že třída JavaScriptSerializer není inicializována pomocí třídy SimpleTypeResolver

|||
|-|-|
|CheckId|CA2322|
|Kategorie|Microsoft.Security|
|Zásadní změna|Nenarušující|

## <a name="cause"></a>Příčina

<xref:System.Web.Script.Serialization.JavaScriptSerializer?displayProperty=nameWithType>Metoda deserializace byla volána nebo odkazována a byla <xref:System.Web.Script.Serialization.JavaScriptSerializer> pravděpodobně inicializována s <xref:System.Web.Script.Serialization.SimpleTypeResolver?displayProperty=nameWithType> .

Ve výchozím nastavení toto pravidlo analyzuje celý základ kódu, ale je možné ho [nakonfigurovat](#configurability).

## <a name="rule-description"></a>Popis pravidla

[!INCLUDE[insecure-deserializers-description](includes/insecure-deserializers-description-md.md)]

Toto pravidlo najde <xref:System.Web.Script.Serialization.JavaScriptSerializer?displayProperty=nameWithType> volání metody deserializace nebo odkazy, pokud je <xref:System.Web.Script.Serialization.JavaScriptSerializer> možné je inicializovat pomocí <xref:System.Web.Script.Serialization.SimpleTypeResolver?displayProperty=nameWithType> .

## <a name="how-to-fix-violations"></a>Jak opravit porušení

- Zajistěte, aby <xref:System.Web.Script.Serialization.JavaScriptTypeResolver?displayPropertyName=nameWithType> objekty nebyly inicializovány pomocí <xref:System.Web.Script.Serialization.SimpleTypeResolver?displayProperty=nameWithType> .
- Pokud váš kód potřebuje číst data serializovaná pomocí <xref:System.Web.Script.Serialization.SimpleTypeResolver> , omezte deserializovatelné typy na očekávaný seznam implementací vlastního <xref:System.Web.Script.Serialization.JavaScriptTypeResolver> .
- Proveďte serializovanou manipulaci s daty. Po serializaci kryptograficky podepisují Serializovaná data. Před deserializací ověřte kryptografický podpis. Chránit kryptografický klíč před zveřejněním a návrhem pro střídání klíčů.

## <a name="when-to-suppress-warnings"></a>Kdy potlačit upozornění

[!INCLUDE[insecure-deserializers-common-safe-to-suppress](includes/insecure-deserializers-common-safe-to-suppress-md.md)]

## <a name="configurability"></a>Konfigurovatelnost

Pokud toto pravidlo spouštíte z [analyzátorů FxCop](install-fxcop-analyzers.md) (a ne pomocí starší verze analýzy), můžete nakonfigurovat analýzu pro toto pravidlo.

### <a name="excluded-symbol-names"></a>Vyloučené názvy symbolů

Můžete nakonfigurovat, které části vašeho základu kódu budou vyloučeny z analýzy. Například chcete-li určit, že pravidlo by nemělo běžet pro žádný kód v rámci typů s názvem `MyType` , přidejte do souboru. editorconfig v projektu následující dvojici klíč-hodnota:

```ini
dotnet_code_quality.CA2322.excluded_symbol_names = MyType
```

Povolené formáty názvů symbolů v hodnotě možnosti (oddělené |):
  - Pouze název symbolu (včetně všech symbolů s názvem, bez ohledu na obsahující typ nebo obor názvů)
  - Plně kvalifikované názvy ve [formátu ID dokumentace k](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)symbolu. Každý název symbolu vyžaduje předponu typu symbolu, jako je například "M:" prefix pro metody, předpona "T:" pro typy, předpona "N:" pro obory názvů atd.
  - `.ctor`pro konstruktory a `.cctor` pro statické konstruktory

Příklady:

| Hodnota možnosti | Souhrn |
| --- | --- |
|`dotnet_code_quality.CA2322.excluded_symbol_names = MyType` | Odpovídá všem symbolům s názvem ' MyType ' v kompilaci
|`dotnet_code_quality.CA2322.excluded_symbol_names = MyType1|MyType2` | Odpovídá všem symbolům s názvem ' MyType1 ' nebo ' MyType2 ' v kompilaci
|`dotnet_code_quality.CA2322.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Odpovídá konkrétní metodě ' MyMethod ' s daným plně kvalifikovaným podpisem
|`dotnet_code_quality.CA2322.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Odpovídá specifickým metodám ' MyMethod1 ' a ' MyMethod2 ' s odpovídajícím plně kvalifikovaným podpisem

Všechny tyto možnosti můžete nakonfigurovat jenom pro toto pravidlo, pro všechna pravidla nebo pro všechna pravidla v této kategorii (zabezpečení). Další informace najdete v tématu [Konfigurace analyzátorů FxCop](configure-fxcop-analyzers.md).

## <a name="pseudo-code-examples"></a>Příklady kódu pseudo

### <a name="violation"></a>Selhání

```csharp
using System.Web.Script.Serialization;

public class ExampleClass
{
    public JavaScriptSerializer Serializer { get; set; }

    public T Deserialize<T>(string str)
    {
        return this.Serializer.Deserialize<T>(str);
    }
}
```

```vb
Imports System.Web.Script.Serialization

Public Class ExampleClass
    Public Property Serializer As JavaScriptSerializer

    Public Function Deserialize(Of T)(str As String) As T
        Return Me.Serializer.Deserialize(Of T)(str)
    End Function
End Class
```

### <a name="solution"></a>Řešení

```csharp
using System.Web.Script.Serialization;

public class ExampleClass
{
    public T Deserialize<T>(string str)
    {
        JavaScriptSerializer s = new JavaScriptSerializer();
        return s.Deserialize<T>(str);
    }
}
```

```vb
Imports System.Web.Script.Serialization

Public Class ExampleClass
    Public Function Deserialize(Of T)(str As String) As T
        Dim s As JavaScriptSerializer = New JavaScriptSerializer()
        Return s.Deserialize(Of T)(str)
    End Function
End Class
```

### <a name="violation"></a>Selhání

```csharp
using System.Web.Script.Serialization;

public class BookRecord
{
    public string Title { get; set; }
    public string Author { get; set; }
    public int PageCount { get; set; }
    public AisleLocation Location { get; set; }
}

public class AisleLocation
{
    public char Aisle { get; set; }
    public byte Shelf { get; set; }
}

public class ExampleClass
{
    public JavaScriptSerializer Serializer { get; set; }

    public BookRecord DeserializeBookRecord(string s)
    {
        return this.Serializer.Deserialize<BookRecord>(s);
    }
}
```

```vb
Imports System.Web.Script.Serialization

Public Class BookRecord
    Public Property Title As String
    Public Property Author As String
    Public Property Location As AisleLocation
End Class

Public Class AisleLocation
    Public Property Aisle As Char
    Public Property Shelf As Byte
End Class

Public Class ExampleClass
    Public Property Serializer As JavaScriptSerializer

    Public Function DeserializeBookRecord(str As String) As BookRecord
        Return Me.Serializer.Deserialize(Of BookRecord)(str)
    End Function
End Class
```

### <a name="solution"></a>Řešení

```csharp
using System;
using System.Web.Script.Serialization;

public class BookRecordTypeResolver : JavaScriptTypeResolver
{
    // For compatibility with data serialized with a JavaScriptSerializer initialized with SimpleTypeResolver.
    private static readonly SimpleTypeResolver Simple = new SimpleTypeResolver();

    public override Type ResolveType(string id)
    {
        // One way to discover expected types is through testing deserialization
        // of **valid** data and logging the types used.

        ////Console.WriteLine($"ResolveType('{id}')");

        if (id == typeof(BookRecord).AssemblyQualifiedName || id == typeof(AisleLocation).AssemblyQualifiedName)
        {
            return Simple.ResolveType(id);
        }
        else
        {
            throw new ArgumentException("Unexpected type ID", nameof(id));
        }
    }

    public override string ResolveTypeId(Type type)
    {
        return Simple.ResolveTypeId(type);
    }
}

public class BookRecord
{
    public string Title { get; set; }
    public string Author { get; set; }
    public int PageCount { get; set; }
    public AisleLocation Location { get; set; }
}

public class AisleLocation
{
    public char Aisle { get; set; }
    public byte Shelf { get; set; }
}

public class ExampleClass
{
    public BookRecord DeserializeBookRecord(string s)
    {
        JavaScriptSerializer serializer = new JavaScriptSerializer(new BookRecordTypeResolver());
        return serializer.Deserialize<BookRecord>(s);
    }
}
```

```vb
Imports System
Imports System.Web.Script.Serialization

Public Class BookRecordTypeResolver
    Inherits JavaScriptTypeResolver

    ' For compatibility with data serialized with a JavaScriptSerializer initialized with SimpleTypeResolver.
    Private Dim Simple As SimpleTypeResolver = New SimpleTypeResolver()

    Public Overrides Function ResolveType(id As String) As Type
        ' One way to discover expected types is through testing deserialization
        ' of **valid** data and logging the types used.

        ''Console.WriteLine($"ResolveType('{id}')")

        If id = GetType(BookRecord).AssemblyQualifiedName Or id = GetType(AisleLocation).AssemblyQualifiedName Then
            Return Simple.ResolveType(id)
        Else
            Throw New ArgumentException("Unexpected type", NameOf(id))
        End If
    End Function

    Public Overrides Function ResolveTypeId(type As Type) As String
        Return Simple.ResolveTypeId(type)
    End Function
End Class

Public Class BookRecord
    Public Property Title As String
    Public Property Author As String
    Public Property Location As AisleLocation
End Class

Public Class AisleLocation
    Public Property Aisle As Char
    Public Property Shelf As Byte
End Class

Public Class ExampleClass
    Public Function DeserializeBookRecord(str As String) As BookRecord
        Dim serializer As JavaScriptSerializer = New JavaScriptSerializer(New BookRecordTypeResolver())
        Return serializer.Deserialize(Of BookRecord)(str)
    End Function
End Class
```

## <a name="related-rules"></a>Související pravidla

[CA2321: Nedeserializovat se třídou JavaScriptSerializer pomocí třídy SimpleTypeResolver](ca2321.md)
