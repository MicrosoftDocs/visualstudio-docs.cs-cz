---
title: C26431
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26431
helpviewer_keywords:
- C26431
ms.assetid: 40be6032-c8de-49ab-8e43-e8eedc0ca0ba
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 81b117563e021cad9c76f503f01aaa422a032361
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011481"
---
# <a name="c26431-dont_test_notnull"></a>C26431 DONT_TEST_NOTNULL

"Typ výrazu je již GSL:: not_null. Netestujte ho na hodnotu null. "

Základní pokyny: F. 23: použijte Not_Null\<t > k označení, že "null" není platná hodnota. **C++**

Typ značky GSL:: not_null z pokynů knihovny podpory se používá k jasnému označení hodnot, které nikdy nepoužívají ukazatele s hodnotou null. Dojde k závažné chybě, pokud takový předpoklad není v době běhu uchováván. Takže není nutné kontrolovat hodnotu null, pokud je výraz vyhodnocen jako výsledek typu GSL:: not_null.

## <a name="remarks"></a>Poznámky

- Vzhledem k tomu, že GSL:: not_null sám je Obálková třída tenkého ukazatele, pravidlo ve skutečnosti sleduje dočasné proměnné, které obsahují výsledky volání přetíženého operátoru převodu (který vrací objekt ukazatele, který obsahuje). Tato logika toto pravidlo platí pro výrazy, které zahrnují proměnné a nakonec výsledky typu GSL:: not_null. Ale aktuálně přeskočí výrazy, které obsahují volání funkcí vracející GSL:: not_null.
  - Aktuální heuristická kontrola hodnoty null detekuje následující kontexty:
  - výraz symbolu v podmínce větve, například if (p) {...};
  - nebitové logické operace;
  - operace porovnání, kde jeden operand je konstantní výraz, který je vyhodnocen jako nula.

## <a name="example"></a>Příklad

nepotřebné kontroly s hodnotou null odhalují logiku s otázkou

```cpp
class type {
public:
    template<class T> bool is() const;
    template<class T> gsl::not_null<const T*> as() const;
    //...
};

class alias_type : public type {
public:
    gsl::not_null<const type*> get_underlying_type() const;
    gsl::not_null<const type*> get_root_type() const
    {
        const auto ut = get_underlying_type();
        if (ut)                                     // C26431
        {
            const auto uat = ut->as<alias_type>();
            if (uat)                                // C26431, also incorrect use of API!
                return uat->get_root_type();

            return ut;
        }

        return this;                                // Alias to nothing? Actually, dead code!
    }
    //...
};
```

zbytečné kontroly s hodnotou null odhalují problematickou logiku – reworking

```cpp
    //...
    gsl::not_null<const type*> get_root_type() const
    {
        const auto ut = get_underlying_type();
        if (ut->is<alias_type>())
            return ut->as<alias_type>()->get_root_type();

        return ut;
    }
    //...
```
