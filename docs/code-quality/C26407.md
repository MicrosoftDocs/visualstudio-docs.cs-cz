---
title: C26407
ms.date: 07/21/2017
ms.topic: conceptual
f1_keywords:
- C26407
helpviewer_keywords:
- C26407
ms.assetid: 5539907a-bfa0-40db-82a6-b860c97209e1
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 771f3e45403141e1e77da2dc941f3e08831577c2
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011830"
---
# <a name="c26407-dont_heap_allocate_unnecessarily"></a>C26407 DONT_HEAP_ALLOCATE_UNNECESSARILY
Aby nedocházelo k zbytečnému použití ukazatelů, snažíme se detekovat běžné vzory místních přidělení, například když je výsledek volání operátoru new uložen v místní proměnné a později explicitně odstraněn. To podporuje pravidlo R. 5: *Preferovat objekty s obory, nepoužívejte zbytečně přidělovat haldu*. Navrhovaná oprava slouží k použití typu RAII namísto nezpracovaného ukazatele a umožnění jeho řešení v práci s prostředky. Pokud je přidělení jeden objekt, může být zjevně zbytečné a místní proměnná typu objektu by mohla fungovat lépe.

## <a name="remarks"></a>Poznámky
- Chcete-li snížit počet upozornění, je tento model zjištěn pouze pro ukazatele vlastníka. Proto je nutné nejprve označit vlastníky. Tuto možnost snadno rozšíříme, aby se pokryly nezpracované ukazatele, pokud obdržíme názory zákazníků na podporu takového scénáře.
- Pojem vymezeného objektu může být neklamný, ale obecný nápad je, že doporučujeme použít místní proměnnou, jejíž doba života je automaticky spravovaná, nebo inteligentní objekt, který efektivně spravuje dynamické prostředky. Inteligentní objekty můžou být v kurzu přidělení haldy, ale nejsou explicitní v kódu.
- Pokud se upozornění aktivuje pro přidělení pole (což je obvykle nutné pro dynamické vyrovnávací paměti), oprava může používat standardní kontejnery nebo `std::unique_pointer<T[]>`.
- Vzor byl zjištěn pouze pro místní proměnné, takže neupozorníme na případy, kdy je přidělení přiřazeno, řekněme, globální proměnná a poté odstraněna ve stejné funkci.

## <a name="example-1-unnecessary-object-allocation-on-heap"></a>Příklad 1: Zbytečné přidělení objektů na haldě

```cpp
auto tracer = new Tracer();
ScanObjects(tracer);
delete tracer;  // C26407
```

## <a name="example-2-unnecessary-object-allocation-on-heap-fixed-with-local-object"></a>Příklad 2: Nepotřebné přidělení objektů na haldě (pevné s lokálním objektem)

```cpp
Tracer tracer;  // OK
ScanObjects(&tracer);
```

## <a name="example-3-unnecessary-buffer-allocation-on-heap"></a>Příklad 3: Zbytečné přidělení vyrovnávací paměti v haldě

```cpp
auto value = new char[maxValueSize];
if (ReadSetting(name, value, maxValueSize))
    CheckValue(value);
delete[] value; // C26407
```

## <a name="example-4-unnecessary-buffer-allocation-on-the-heap-fixed-with-container"></a>Příklad 4: Zbytečné přidělení vyrovnávací paměti na haldě (s pevným kontejnerem)

```cpp
auto value = std::vector<char>(maxValueSize); // OK
if (ReadSetting(name, value.data(), maxValueSize))
    CheckValue(value.data());
```
