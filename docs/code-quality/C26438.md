---
title: C26438
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26438
helpviewer_keywords:
- C26438
ms.assetid: c7b3f59c-fb2f-4816-bda4-0fad23c80d83
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: e8d074e68f2ad2978e261e587221898e69ae3ad1
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/07/2019
ms.locfileid: "72016514"
---
# <a name="c26438-no_goto"></a>C26438 NO_GOTO

"Vyhněte se příkazu goto".

**C++ Základní pokyny**: ES. 76: Vyhněte se goto

Použití příkazu goto je široce potvrzené jako nebezpečné a v praxi náchylné k chybám. Je přijatelné pouze v generovaném kódu (např. v analyzátoru vygenerovaném z gramatiky). Díky moderním C++ funkcím a nástrojům, které poskytuje pokyny pro podporu knihovny, by se mělo snadno vyhnout příkazu goto.

## <a name="remarks"></a>Poznámky

- Toto pravidlo se upozorní na libovolný výskyt příkazu goto, i když k němu dojde v nedoručeném kódu, s výjimkou kódu šablony, který se nikdy nepoužívá, a proto je kompilátorem ignorován.
  - Pokud narazíte na makro obsahující příkaz goto, můžou být upozornění na vysokou úroveň. Aktuální mechanismus generování sestav by odkazoval na všechny instance, kde se toto makro rozšíří. Tuto opravu lze ale obvykle provést na jednom místě změnou makra nebo zabráněním použití IT a využitím více udržovatelných mechanismů.

## <a name="example"></a>Příklad

goto Cleanup v makru

```cpp
#define ENSURE(E, L) if (!(E)) goto L;

void poll(connection &c)
{
    ENSURE(c.open(), end);                  // C26438

    while (c.wait())
    {
        connection::header h{};
        connection::signature s{};
        ENSURE(c.read_header(h), end);      // C26438
        ENSURE(c.read_signature(s), end);   // C26438
        // ...
    }

end:
    c.close();
}
```

goto Cleanup v makru – nahrazené GSL:: finally

```cpp
void poll(connection &c)
{
    auto end = gsl::finally([&c] { c.close(); });

    if (!c.open())
        return;

    while (c.wait())
    {
        connection::header h{};
        connection::signature s{};
        if(!c.read_header(h))
            return;
       if(!c.read_signature(s))
            return;
        // ...
    }
}
```
