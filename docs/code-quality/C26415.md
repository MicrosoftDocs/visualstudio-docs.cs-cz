---
title: C26415
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26415
helpviewer_keywords:
- C26415
ms.assetid: 4165f70a-78ae-4a03-b256-c4bd74b02d09
author: corob-msft
ms.author: corob
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 9ef7e3c106f403cacf8ffb1a38610ae08cf3c711
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 02/15/2020
ms.locfileid: "77261072"
---
# <a name="c26415-smart_ptr_not_needed"></a>C26415 SMART_PTR_NOT_NEEDED

"Parametr inteligentního ukazatele se používá pouze pro přístup k obsaženému ukazateli. Místo toho použijte & T * nebo T. "

Základní pokyny: R. 30: přebírat inteligentní ukazatele jako parametry pouze pro explicitní výslovnou sémantiku životního cyklu **C++**

Použití inteligentního ukazatele typu k předání dat funkci znamená, že cílová funkce musí spravovat životnost obsaženého objektu. Nicméně pokud funkce používá inteligentní ukazatel k přístupu k obsaženému objektu a nikdy nevolá žádný kód, který by mohl vést k navrácení jeho zrušení (to znamená, že nikdy nemá vliv na svou životnost), není obvykle nutné zkomplikovat rozhraní pomocí inteligentních ukazatelů. Upřednostňuje se jednoduchý ukazatel nebo odkaz na objekt, který jej obsahuje.

## <a name="remarks"></a>Poznámky

Tato kontrolu pokrývá většinu scénářů, které také způsobují C26410, C26415, C26417 a C26418. Je lepší nejprve vyčistit SMART_PTR_NOT_NEEDED a pak přepnout do hraničních případů pro sdílené nebo jedinečné ukazatele. Pro další cílené vyčištění je možné toto upozornění zakázat.

Kromě standardních šablon std:: unqiue_pointer a std:: shared_pointer tato kontroly rozpoznává uživatelsky definované typy, které jsou pravděpodobně určeny pro inteligentní ukazatele. U těchto typů se očekává definování následujících operací:

- Přetížené nebo vyhrazené operátory přístupu členů, které jsou veřejné a nejsou označené jako odstraněné.
- Veřejný destruktor, který není odstraněn nebo nastaven jako výchozí. To zahrnuje destruktory, které jsou explicitně definovány jako prázdné.

Výklad operací, které mohou ovlivnit životnost obsažených objektů, je široké a zahrnuje:

- Všechny funkce, které přijímají ukazatel nebo parametr reference na nekonstantní inteligentní ukazatel
- Kopírování nebo přesun konstruktorů nebo operátorů přiřazení
- Nekonstantní funkce

## <a name="example"></a>Příklad

Náročná Správa životního cyklu.

```cpp
bool set_initial_message(
            const std::unique_ptr<message> &m) // C26415, also C26410 NO_REF_TO_CONST_UNIQUE_PTR
{
    if (!m || initial_message_)
        return false;

    initial_message_.reset(m.get());
    return true;
}

void pass_message(const message_info &info)
{
    auto m = std::make_unique<message>(info);
    const auto release = set_initial_message(m);
    // ...
    if (release)
        m.release();
}
```

## <a name="example"></a>Příklad

Náročná Správa životního cyklu – přepracovaná.

```cpp
void set_initial_message(std::shared_ptr<message> m) noexcept
{
    if (m && !initial_message_)
        initial_message_ = std::move(m);
}

void pass_message(const message_info &info)
{
    auto m = std::make_shared<message>(info);
    set_initial_message(m);
    // ...
}
```
